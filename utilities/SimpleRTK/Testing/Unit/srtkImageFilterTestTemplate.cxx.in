/*=========================================================================
*
*  Copyright Insight Software Consortium & RTK Consortium
*
*  Licensed under the Apache License, Version 2.0 (the "License");
*  you may not use this file except in compliance with the License.
*  You may obtain a copy of the License at
*
*         http://www.apache.org/licenses/LICENSE-2.0.txt
*
*  Unless required by applicable law or agreed to in writing, software
*  distributed under the License is distributed on an "AS IS" BASIS,
*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*  See the License for the specific language governing permissions and
*  limitations under the License.
*
*=========================================================================*/
/*
 * WARNING: DO NOT EDIT THIS FILE!
 * THIS FILE IS AUTOMATICALLY GENERATED BY THE SIMPLERTK BUILD PROCESS.
 * Please look at srtkImageFilterTestTemplate.cxx.in to make changes.
 */

#include <SimpleRTKTestHarness.h>

#include <srtk${name}.h>
#include <srtkImageFileReader.h>
#include <srtkImageFileWriter.h>
#include <srtkHashImageFilter.h>
#include <srtkCastImageFilter.h>
#include <srtkVersion.h>


TEST(BasicFilters,${name}) {
  rtk::simple::ImageFileReader reader;
  rtk::simple::${name} filter;
  rtk::simple::Image inputA( 0, 0, rtk::simple::srtkUInt8 );
  rtk::simple::Image inputB( 0, 0, rtk::simple::srtkUInt8 );
  rtk::simple::Image output( 0, 0, rtk::simple::srtkUInt8 );
  std::string inputSHA1hash;

  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

$(foreach members
  $(if dim_vec and dim_vec == 1 then
  OUT=[[for(unsigned int i = 0; i < filter.Get${name}().size(); ++i)
    {
    EXPECT_EQ ( filter.Get${name}()[i], ${default}[i] ) << "Testing get for ${name} at " << i;
    }]]
  elseif no_print == nil then
  OUT=[[EXPECT_EQ ( filter.Get${name}(), ${default} ) << "Testing get for ${name}";]]
end)
)
  EXPECT_NE ( filter.ToString(), "" ) << "empty ToString method!";
  EXPECT_EQ ( filter.GetName(), "${name}" ) << "checking GetName method!";

  // Test sets / gets
$(foreach members
  $(if dim_vec and dim_vec == 1 then
  OUT=[[filter.Set${name} ( ${default} );
  for(unsigned int i = 0; i < filter.Get${name}().size(); ++i)
    {
    EXPECT_EQ ( filter.Get${name}()[i], ${default}[i] ) << "Testing set/get for ${name} at " << i;
    }]]
  elseif no_print == nil then
  OUT=[[filter.Set${name} ( ${default} );
  EXPECT_EQ ( filter.Get${name}(), ${default} ) << "Testing set/get for ${name}";]]
end)
)

$(if template_type and template_type == "RegionGrowing" then OUT=[[
  // Test size of default SeedList
  EXPECT_EQ ( filter.GetSeedList().size(), (unsigned int)0 ) << "Testing empty seed list as default";]]
end)

$(if template_code_filename and template_code_filename == "FastMarchingImageFilter" then OUT=[[
  // Test size of default TrialPoints
  EXPECT_EQ ( filter.GetTrialPoints().size(), (unsigned int)0 ) << "Testing empty trial points as default";]]
end)

 $(if number_of_inputs == 2 then
   OUT=[[ {
  rtk::simple::Image smallImage( 1,1,1,rtk::simple::srtkUInt8 );
  rtk::simple::Image largeImage( 10,10,10,rtk::simple::srtkUInt8 );
  rtk::simple::Image smallShortImage( 1,1,1,rtk::simple::srtkUInt16 );
  try
    {
    // Try executing with different size images.
    // This will either work or throw an exception, either is OK. So
    // this is here just to make sure that the behavior does not cause
    // undefined behavior such as segfault, or other errouneos behavior.
    filter.Execute ( largeImage, smallImage );
    } catch (... )
    { }
]]
  if template_code_filename and template_code_filename == "DualImageFilter" then
    OUT = OUT .. [=[
        // todo add intelligence to determin some image types to test
        //ASSERT_NO_THROW ( filter.Execute ( smallImage, smallShortImage ) ) << " Image types are different";
]=]
  else
    OUT = OUT .. [=[

  ASSERT_THROW ( filter.Execute ( smallImage, smallShortImage ), rtk::simple::GenericException ) << " Image types are different"; ]=]
  end
  OUT = OUT .. [[
  }]]
   end)
}

$(foreach tests
TEST(BasicFilters,${name}_${tag})
  { // BEGIN FOR EACH TEST
  /* TAG: ${tag} DESCRIPTION: ${description} */

  rtk::simple::ImageFileReader reader;
  rtk::simple::${name} filter;
  rtk::simple::Image output;
  rtk::simple::HashImageFilter hasher;
  std::string inputSHA1hash;

  std::vector<rtk::simple::Image> inputs;
  std::vector<std::string> inputFileNames;

$(for inum=1,#inputs do
    OUT=OUT..[[
  inputFileNames.push_back( "]]..inputs[inum]..[["  );
]]
end)

  for ( unsigned int i = 0; i < inputFileNames.size(); ++i )
    {
    ASSERT_NO_THROW ( inputs.push_back( reader.SetFileName ( dataFinder.GetFile ( inputFileNames[i]  ) ).Execute() ) ) << "Failed to load " << inputFileNames[i] << " from " << dataFinder.GetFile ( inputFileNames[i]  );

$(if inputA_cast then
      OUT=[[
      if ( i == 0 )
        {
          ASSERT_NO_THROW( inputs[i]  = rtk::simple::Cast( inputs[i], rtk::simple::${inputA_cast } ) ) << "Failed to cast inputA to ${inputA_cast}";
        }
]] end)$(if inputB_cast then
      OUT=[[
    if ( i == 1 )
      {
      ASSERT_NO_THROW( inputs[i] = rtk::simple::Cast( inputs[i], rtk::simple::${inputB_cast } ) ) << "Failed to cast inputB to ${inputB_cast}";
      }
]] end)
    ASSERT_TRUE ( inputs[i].GetITKBase() != NULL ) << "Could not read " << inputFileNames[i];
    }

  $(if (not no_procedure) or (no_procedure ==0) then
OUT=[=[

      // Do we get the same image back, if we use the functional interface?
      rtk::simple::Image fromFunctional( 0, 0, rtk::simple::srtkUInt8 );
      rtk::simple::Image fromProcedural( 0, 0, rtk::simple::srtkUInt8 );
      ASSERT_NO_THROW ( fromProcedural = filter.Execute ( $(if #inputs > 0 then OUT=[[inputs[0] ]] end)$(for inum=1,#inputs-1 do OUT=OUT..", inputs["..inum.."]" end) ) ) << "Procedural interface to ${name}";
      ASSERT_NO_THROW ( fromFunctional = rtk::simple::${name:gsub("ImageFilter$", ""):gsub("ImageSource$", "Source")} ( $(if #inputs > 0 then OUT=[[inputs[0] ]] end)$(for inum=1,#inputs-1 do OUT=OUT..", inputs["..inum.."]" end)
                                                                       $(if template_type and template_type == "RegionGrowing" then OUT=", std::vector< std::vector<unsigned int> >()" end)
                                                                       $(if template_code_filename and template_code_filename == "FastMarchingImageFilter" then OUT=", std::vector< std::vector<unsigned int> >()" end)
                                                                       $(if template_code_filename and template_code_filename == "KernelImageFilter" then OUT=[[, 1, rtk::simple::srtkBall]] end)
                                                                       $(for i = 1,#members do
                                                                         if (number_of_inputs > 0 or i > 1) then OUT = OUT .. ", " end
                                                                         OUT= OUT .. members[i].default
                                                                        end)


                                                                      ) ) << "Functional interface to ${name}";
      hasher.SetHashFunction ( rtk::simple::HashImageFilter::MD5 );
      EXPECT_EQ ( hasher.Execute ( fromProcedural ), hasher.Execute ( fromFunctional ) ) << "procedural and functional are not the same!";
]=] end)


$(if settings then
OUT=[[
$(foreach settings
  $(if parameter == "SeedList" then
  OUT='filter.ClearSeeds();\
  $(for i=1,#value do OUT=OUT .. "{unsigned int __seed[] = " .. value[i] .. "; filter.AddSeed( std::vector<unsigned int>(__seed, __seed + inputs[0].GetDimension()) );}" end);'
  elseif parameter == "TrialPoints" then
  OUT='filter.ClearTrialPoints();\
  $(for i=1,#value do OUT=OUT .. "{unsigned int __point[] = " .. value[i] .. "; filter.AddTrialPoint( std::vector<unsigned int>(__point, __point + inputs[0].GetDimension()) );}" end);'
  elseif dim_vec and dim_vec == 1 then
  OUT='{\
  ${type} arr[] = {'
  for i=1,#value-1 do
    OUT=OUT..value[i]..", "
  end
  OUT=OUT..value[#value]
  OUT=OUT..'};\
  std::vector< ${type} > vec(arr, arr + sizeof(arr)/sizeof(${type}));\
  filter.Set${parameter} ( vec );\
  for(unsigned int i = 0; i < filter.Get${parameter}().size(); ++i)\
    {\
    ASSERT_EQ ( filter.Get${parameter}()[i], vec[i] ) << "Failed to set ${parameter} to ${value}";\
    }\
  }'
  else
    OUT='filter.Set${parameter} ( ${value} );'
      if (not no_get_method) then
        if (value == "true") then
          OUT = OUT .. '\
  ASSERT_TRUE ( filter.Get${parameter}() ) << "Failed to set ${parameter} to ${value}";'
        elseif (value == "false") then
          OUT = OUT .. '\
  ASSERT_FALSE ( filter.Get${parameter}() ) << "Failed to set ${parameter} to ${value}";'
        else
          OUT = OUT .. '\
  ASSERT_EQ ( ${value}, filter.Get${parameter}() ) << "Failed to set ${parameter} to ${value}";'
        end
      end
end)
)]]
end)


    if ( !inputs.empty() &&
         inputs[0].GetPixelID() != rtk::simple::srtkLabelUInt8 &&
         inputs[0].GetPixelID() != rtk::simple::srtkLabelUInt16 &&
         inputs[0].GetPixelID() != rtk::simple::srtkLabelUInt32 &&
         inputs[0].GetPixelID() != rtk::simple::srtkLabelUInt64 )
      {
      inputSHA1hash =  rtk::simple::Hash( inputs[0] );
      }
   filter.DebugOn();
   ASSERT_NO_THROW ( output =  filter.Execute ( $(if #inputs > 0 then OUT=[[inputs[0] ]] end)$(for inum=1,#inputs-1 do OUT=OUT..", inputs["..inum.."]" end) ) );

    if ( !inputs.empty() &&
         inputs[0].GetPixelID() != rtk::simple::srtkLabelUInt8 &&
         inputs[0].GetPixelID() != rtk::simple::srtkLabelUInt16 &&
         inputs[0].GetPixelID() != rtk::simple::srtkLabelUInt32 &&
         inputs[0].GetPixelID() != rtk::simple::srtkLabelUInt64 )
      {
      // Check that the input is not modified
      // This will fail if the filter is being run in-place
      EXPECT_EQ ( inputSHA1hash,  rtk::simple::Hash( inputs[0] ) ) << "Input was modified by filter.";
      }

  $(if md5hash then
  OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${md5hash}",MD5,output,"Output MD5 hash failed in ${tag}");]]
  end)
  $(if sha1hash then
  OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed in ${tag}"); ]]
  end) $(if tolerance then
  OUT = [[
 IMAGECOMPAREWITHTOLERANCE ( output, "", ${tolerance} );
  ]]end) $(when measurements_results
$(foreach measurements_results
$(if tolerance then
        OUT=[[EXPECT_NEAR(${value}, filter.Get${name}(), ${tolerance} );]]
else
  if (value == "true") then
    OUT = [[EXPECT_TRUE ( filter.Get${name}() ) << "Measurement failure";]]
  elseif (value == "false") then
    OUT = [[EXPECT_FALSE ( filter.Get${name}() ) << "Measurement failure";]]
  else
    OUT = [[EXPECT_EQ ( ${value}, filter.Get${name}() ) << "Measurement failure";]]
  end
end)
))

} // END FOR EACH TEST
)


#if defined(WRAP_LUA)

TEST_F(Lua,${name}) {
  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

  std::string Script = dataFinder.GetBuildDirectory() + "/Testing/Unit/LuaTests/${name}Test.lua";
  $(foreach tests
    {
    /* ${description} */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "Lua-${name}-${tag}.nrrd" );
    // Make sure the output is deleted
    if ( itksys::SystemTools::FileExists ( outputFileName.c_str() ) ) {
      ASSERT_TRUE ( itksys::SystemTools::RemoveFile ( outputFileName.c_str() ) ) << "Deleting file " << outputFileName;
    }
    CommandLine = dataFinder.GetLuaExecutable();
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "${tag}" );
$(for inum=1,#inputs do
    OUT=OUT..[[
  CommandLine.push_back( dataFinder.GetFile ("]]..inputs[inum]..[[")  );
]] end)
    CommandLine.push_back ( outputFileName );
    EXPECT_EQ( 0, RunExecutable ( CommandLine, true ) ) << "non-zero returned from process";
    ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    rtk::simple::ImageFileReader reader;
    rtk::simple::HashImageFilter hasher;
    rtk::simple::Image output( 0, 0, rtk::simple::srtkUInt8 );

    output = reader.SetFileName ( outputFileName ).Execute();
    ASSERT_TRUE ( output.GetITKBase() != NULL ) << "Loaded output image";

    $(if md5hash then
      OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${md5hash}",MD5,output,"Output MD5 hash failed");
               ]]
      end)
    $(if sha1hash then
      OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed");
               ]]
      end)
    $(if tolerance then
      OUT = [[
              IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output, "BasicFilters", "${tag}", ${tolerance} );
               ]]
      end)
      }
    )
}
#endif

#if defined(WRAP_PYTHON)

TEST_F(Python,${name}) {
  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

  std::string Script = dataFinder.GetBuildDirectory() + "/Testing/Unit/PythonTests/${name}Test.py";
  $(foreach tests
    {
    /* ${description} */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "Python-${name}-${tag}.nrrd" );
    // Make sure the output is deleted
    if ( itksys::SystemTools::FileExists ( outputFileName.c_str() ) ) {
      ASSERT_TRUE ( itksys::SystemTools::RemoveFile ( outputFileName.c_str() ) ) << "Deleting file " << outputFileName;
    }
    CommandLine = dataFinder.GetPythonExecutable();
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "${tag}" );
$(for inum=1,#inputs do
    OUT=OUT..[[
  CommandLine.push_back( dataFinder.GetFile ("]]..inputs[inum]..[[")  );
]] end)
    CommandLine.push_back ( outputFileName );
    EXPECT_EQ( 0, RunExecutable ( CommandLine, true ) ) << "non-zero returned from process";
    ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    rtk::simple::ImageFileReader reader;
    rtk::simple::HashImageFilter hasher;
    rtk::simple::Image output( 0, 0, rtk::simple::srtkUInt8 );

    output = reader.SetFileName ( outputFileName ).Execute();
    ASSERT_TRUE ( output.GetITKBase() != NULL ) << "Loaded output image";

    $(if md5hash then
      OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${md5hash}",MD5,output,"Output MD5 hash failed");
               ]]
      end)
    $(if sha1hash then
      OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed");
               ]]
      end)
    $(if tolerance then
      OUT = [[
              IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output, "BasicFilters", "${tag}", ${tolerance} );
               ]]
      end)
      }
    )
}
#endif

#if defined(WRAP_TCL)

TEST_F(Tcl,${name}) {
  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

  std::string Script = dataFinder.GetBuildDirectory() + "/Testing/Unit/TclTests/${name}Test.tcl";
  $(foreach tests
    {
    /* ${description} */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "Tcl-${name}-${tag}.nrrd" );
    // Make sure the output is deleted
    if ( itksys::SystemTools::FileExists ( outputFileName.c_str() ) ) {
      ASSERT_TRUE ( itksys::SystemTools::RemoveFile ( outputFileName.c_str() ) ) << "Deleting file " << outputFileName;
    }
    CommandLine = dataFinder.GetTclExecutable ( );
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "${tag}" );
$(for inum=1,#inputs do
    OUT=OUT..[[
  CommandLine.push_back( dataFinder.GetFile ("]]..inputs[inum]..[[")  );
]] end)
    CommandLine.push_back ( outputFileName );
    EXPECT_EQ( 0, RunExecutable ( CommandLine, true ) ) << "non-zero returned from process";
    ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    rtk::simple::ImageFileReader reader;
    rtk::simple::HashImageFilter hasher;
    rtk::simple::Image output( 0, 0, rtk::simple::srtkUInt8 );

    output = reader.SetFileName ( outputFileName ).Execute();
    ASSERT_TRUE ( output.GetITKBase() != NULL ) << "Loaded output image";

    $(if md5hash then
      OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${md5hash}",MD5,output,"Output MD5 hash failed");
               ]]
      end)
    $(if sha1hash then
      OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed");
               ]]
      end)
    $(if tolerance then
      OUT = [[
              IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output, "BasicFilters", "${tag}", ${tolerance} );
               ]]
      end)
      }
    )
}
#endif

#if defined(WRAP_R)

TEST_F(R,${name}) {
  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

  // Set-up the R enviroment to include the SimpleRTK R library in the
  // build directory.
  SetEnvironment ( "R_LIBS", dataFinder.GetBuildDirectory()+"/Wrapping/RLib" );


  std::string Script = dataFinder.GetBuildDirectory() + "/Testing/Unit/RTests/${name}Test.R";
  $(foreach tests
    {

    /* ${description} */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "R-${name}-${tag}.nrrd" );
    // Make sure the output is deleted
    if ( itksys::SystemTools::FileExists ( outputFileName.c_str() ) ) {
      ASSERT_TRUE ( itksys::SystemTools::RemoveFile ( outputFileName.c_str() ) ) << "Deleting file " << outputFileName;
    }
    CommandLine = dataFinder.GetRExecutable();
    CommandLine.push_back ( "--slave" );
    CommandLine.push_back ( "--vanilla" );
    CommandLine.push_back ( std::string("--file=")+Script );
    CommandLine.push_back ( "--args" );
    CommandLine.push_back ( "${tag}" );
$(for inum=1,#inputs do
    OUT=OUT..[[
  CommandLine.push_back( dataFinder.GetFile ("]]..inputs[inum]..[[")  );
]] end)
    CommandLine.push_back ( outputFileName );
    EXPECT_EQ( 0, RunExecutable ( CommandLine, true ) ) << "non-zero returned from process";
    ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    rtk::simple::ImageFileReader reader;
    rtk::simple::HashImageFilter hasher;
    rtk::simple::Image output( 0, 0, rtk::simple::srtkUInt8 );

    output = reader.SetFileName ( outputFileName ).Execute();
    ASSERT_TRUE ( output.GetITKBase() != NULL ) << "Loaded output image";

    $(if md5hash then
      OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${md5hash}",MD5,output,"Output MD5 hash failed");
               ]]
      end)
    $(if sha1hash then
      OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed");
               ]]
      end)
    $(if tolerance then
      OUT = [[
              IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output, "BasicFilters", "${tag}", ${tolerance} );
               ]]
      end)
      }

    )
}
#endif



#if defined(WRAP_JAVA)

TEST_F(Java,${name}) {
  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

  std::string Classpath = dataFinder.GetBuildDirectory() + "/Testing/Unit/JavaTests"
    + dataFinder.GetPathSeparator() + dataFinder.GetBuildDirectory() + "/Wrapping/simplertk-" + rtk::simple::Version::VersionString() + ".jar";
  std::string JavaPath = dataFinder.GetLibraryDirectory();
  std::string Script = "org.rtk.simple.testing.${name}Test";
  $(foreach tests
    {
    /* ${description} */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "Java-${name}-${tag}.nrrd" );
    // Make sure the output is deleted
    if ( itksys::SystemTools::FileExists ( outputFileName.c_str() ) ) {
      ASSERT_TRUE ( itksys::SystemTools::RemoveFile ( outputFileName.c_str() ) ) << "Deleting file " << outputFileName;
    }
    CommandLine = dataFinder.GetJavaExecutable();
    CommandLine.push_back ( "-classpath" );
    CommandLine.push_back ( Classpath );
    CommandLine.push_back ( "-Djava.library.path=" + JavaPath );
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "${tag}" );
$(for inum=1,#inputs do
    OUT=OUT..[[
  CommandLine.push_back( dataFinder.GetFile ("]]..inputs[inum]..[[")  );
]] end)
    CommandLine.push_back ( outputFileName );
    EXPECT_EQ( 0, RunExecutable ( CommandLine, true ) ) << "non-zero returned from process";
    ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    rtk::simple::ImageFileReader reader;
    rtk::simple::HashImageFilter hasher;
    rtk::simple::Image output( 0, 0, rtk::simple::srtkUInt8 );

    output = reader.SetFileName ( outputFileName ).Execute();
    ASSERT_TRUE ( output.GetITKBase() != NULL ) << "Loaded output image";

    $(if md5hash then
      OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${md5hash}",MD5,output,"Output MD5 hash failed");
               ]]
      end)
    $(if sha1hash then
      OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed");
               ]]
      end)
    $(if tolerance then
      OUT = [[
              IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output, "BasicFilters", "${tag}", ${tolerance} );
               ]]
      end)
      }
    )
}
#endif

#if defined(WRAP_RUBY)

TEST_F(Ruby,${name}) {
  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

  // Set our Ruby path
  SetEnvironment ( "RUBYLIB", dataFinder.GetLibraryDirectory() );

  std::string Script = dataFinder.GetBuildDirectory() + "/Testing/Unit/RubyTests/${name}Test.rb";
  $(foreach tests
    {
    /* ${description} */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "Ruby-${name}-${tag}.nrrd" );
    // Make sure the output is deleted
    if ( itksys::SystemTools::FileExists ( outputFileName.c_str() ) ) {
      ASSERT_TRUE ( itksys::SystemTools::RemoveFile ( outputFileName.c_str() ) ) << "Deleting file " << outputFileName;
    }
    CommandLine = dataFinder.GetRubyExecutable();
    CommandLine.push_back ( Script );
    CommandLine.push_back ( "${tag}" );
$(for inum=1,#inputs do
    OUT=OUT..[[
  CommandLine.push_back( dataFinder.GetFile ("]]..inputs[inum]..[[")  );
]] end)
    CommandLine.push_back ( outputFileName );
    EXPECT_EQ( 0, RunExecutable ( CommandLine, true ) ) << "non-zero returned from process";
    ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    rtk::simple::ImageFileReader reader;
    rtk::simple::HashImageFilter hasher;
    rtk::simple::Image output( 0, 0, rtk::simple::srtkUInt8 );

    output = reader.SetFileName ( outputFileName ).Execute();
    ASSERT_TRUE ( output.GetITKBase() != NULL ) << "Loaded output image";

    $(if md5hash then
      OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${md5hash}",MD5,output,"Output MD5 hash failed");
               ]]
      end)
    $(if sha1hash then
      OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed");
               ]]
      end)
    $(if tolerance then
      OUT = [[
              IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output, "BasicFilters", "${tag}", ${tolerance} );
               ]]
      end)
      }
    )
}
#endif

#if defined(WRAP_CSHARP)

TEST_F(CSharp,${name}) {
  $(if #tests == 0 then
    OUT=[[
  FAIL() << "Filter ${name} has no tests defined";
        ]]
    end)

  std::string ExePath = dataFinder.GetCSharpBinaryDirectory();
  std::string ExeName = "Test${name}.exe";
  std::string ExePathAndName = ExePath + "/" + ExeName;

  // On Linux, we need to specify where the shared library is found
  std::string path = dataFinder.GetBuildDirectory() + "/Wrapping/CSharpBinaries";
  SetEnvironment ( "LD_LIBRARY_PATH", path );


  $(foreach tests
    {
    /* ${description} */
    std::vector<std::string> CommandLine;
    std::string outputFileName = dataFinder.GetOutputFile ( "CSharp-${name}-${tag}.nrrd" );

    // Make sure the output is deleted
    if ( itksys::SystemTools::FileExists ( outputFileName.c_str() ) ) {
      ASSERT_TRUE ( itksys::SystemTools::RemoveFile ( outputFileName.c_str() ) ) << "Deleting file " << outputFileName;
    }

    std::vector<std::string> cs_interp = dataFinder.GetCSharpInterpreter();

    if ( cs_interp.size() && cs_interp[0].size() )
    {
      CommandLine = dataFinder.GetCSharpInterpreter();
    }
    CommandLine.push_back ( ExePathAndName );
    CommandLine.push_back ( dataFinder.GetFile ( "Input/RA-Short.nrrd" ).c_str() );
    CommandLine.push_back ( "${tag}" );
$(for inum=1,#inputs do
    OUT=OUT..[[
  CommandLine.push_back( dataFinder.GetFile ("]]..inputs[inum]..[[")  );
]] end)
    CommandLine.push_back ( outputFileName );
    EXPECT_EQ( 0, RunExecutable ( CommandLine, true ) ) << "non-zero returned from process";
    ASSERT_TRUE ( dataFinder.FileExists ( outputFileName ) );
    rtk::simple::ImageFileReader reader;
    rtk::simple::HashImageFilter hasher;
    rtk::simple::Image output( 0, 0, rtk::simple::srtkUInt8 );

    output = reader.SetFileName ( outputFileName ).Execute();
    ASSERT_TRUE ( output.GetITKBase() != NULL ) << "Loaded output image";

    $(if md5hash then
      OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${md5hash}",MD5,output,"Output MD5 hash failed");
               ]]
      end)
    $(if sha1hash then
      OUT = [[
  // Check the hash
  IMAGECOMPAREWITHHASH("${sha1hash}",SHA1,output,"Output SHA1 hash failed");
               ]]
      end)
    $(if tolerance then
      OUT = [[
              IMAGECOMPAREWITHTOLERANCE_WITH_TESTCASE ( output, "BasicFilters", "${tag}", ${tolerance} );
               ]]
      end)
      }
    )
}
#endif
